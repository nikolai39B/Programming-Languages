Programming Languages Notes

02/19/16

Introduction to Racket
-   Basics
    -   functional focus
    -   no pattern matching
    -   parentheses very important
    -   start files with '#lang racket'
    -   comments start with ';'
    -   dynamically typed
-   Parentheses
    -   denote a function call
    -   (FUNC_NAME PARAM1 PARAM2 ...)
    -   Ex:
        (foo x y) ; call foo(x, y)
        (= y 3) ; evaluate y == 3
    -   never extraneous
        -   (e) means call e with zero arguments
        -   ((e)) means call e with zero arguments, then call the result with zero arguments
    -   can use [] in place of ()
-   Defining Functions
    -   (define (FUNC_NAME PARAM1 PARAM2 ...)
            FUNC_BODY)
    -   Ex:
        (define (cube x)
            (* x x x))
    -   can also do it anonymously
        -   use 'lambda' expression
        -   (lambda (PARAM1 PARAM2 ...) 
                FUNC_BODY)
        -   Ex:
            (define cube
                (lambda (x)
                    (* x x x)))
-   List Processing
    -   build in methods
        -   empty list: null
        -   cons constructor: cons
        -   head: car
        -   tail: cdr
        -   check for empty: null?
    -   building lists
        - (list e1 ... en)
-   Racket Syntax
    -   terms
        -   atoms: 34, "hi", null, x, #t, ...
        -   special forms: define, lambda, if, ...
        -   sequence of terms in parentheses: (t1 t2 ... tn)
-   Conditionals
    -   use 'cond' in place of nested ifs
    -   (cond [case1 result1]
              [case2 result2]
              ...
              [caseN resultN])
    -   good style: caseN should be #t
    
Local Bindings
-   Let
    -   binds any number of local variables
    -   expressions are evaluated in the environment from before the 'let' expression
    -   Ex:
        (let ([x (+ 2 3)]
              [y (- 10 7)])
            (+ x y -2))
-   Let*
    -   same as let, but also considers bindings generated earlier in the 'let*' expression
-   Letrec
    -   same as let*, but considers all bindings generated in the 'letrec' expression
    
Mutation
-   Set!
    -   'set!' functions mutate values
    -   Ex:
        (define a 4)    ; a = 4
        (println a)     ; prints 4
        (set! a 21)     ; a = 21
        (println a)     ; prints 21

02/10/16

Modules
-   Structures
    -   Use structures to define modules
    -   Ex:
        structure MyModule =
        struct
            fun fact(x) =
                <FUNCTION>
            val half_pi = Math.pi / 2.0
            fun doubler(x) = 
                x * 2
        end
    -   More than just namespace management
-   Signatures
    -   Signature is a type for a module
    -   Can define a signature and ascribe it to a module
    -   Ex:
        signature MATHLIB =
        sig
            val fact : int -> int
            val half_pi : real
            val doubler : int -> int -> ?a 'a #4
        end
    -   Assigning a signature to a module:
            structure MyModule :> <SIGNAME> =
            struct
                <BINDINGS>
            end
        -   Module must match the signature
    -   Can add functions to modules that aren't in the signature
        -   They become "private"
        
Type-Checking
-   Static vs Dynamic
    -   Static: ensure that all signatures are correct before program runs
    -   Dynamic: allow signatures to change
-   Implicit typing
    -   Will infer type from context
    -   Can still be static
    -   Steps
        -   Determine all bindings in order (to allow later functions to use earlier ones)
        -   Analyze fun/val bindings for all necessary constraints
        -   Type error any issues
        -   Give generic types ('a) for unconstrained types
		
02/08/16

Function Composition
-   Ex:
    fun compose(f, g) =
        fn x => f(g(x))
-   Composes right-to-left by default
    -   Use the infix operator to do left-to-right
    -   Ex:
        infix |>
        fun x |> f = 
            f(x)
        
        fun sqrtOfAbs i =
            i |> abs |> Real.fromInt |> Math.sqrt
            
References
-   Allows for mutation
-   t ref (where t is a type)
-   Ex:
    ref e       (* Create reference with initial contents e *)
    e1 := e2    (* Update contents *)
    !e          (* Retrieve contents *)

02/05/16

Functional Scoping
-   Types
    -   Lexical scope - environment where function is defined
    -   Dynamic scope - environment where function is called
-   Prefer lexical scope
-   Why lexical scope?
    -   Function meaning does not depend on variable names used
    -   Functions can be type-checked
    -   Closures can easily store the data they need
    
02/03/16

Inferred Types
-	Used in function arguments
-	Ex:
	fun n_times (f,n,x) =
		if 
			n = 0
		then 
			x
		else 
			f(n_times(f, n - 1, x))
			
Anonymous Functions
-	Declared using fn ([args]) => [body]
-	Ex:
	fun triple_n_times (f, x) =
		n_times((fn y => 3  * y), n, x)

02/01/16

Exceptions
-	Ex: ([] means optional)
	exception MyException [of int * int]
	raise (MyException [(7, 9)] )
	e1 handle MyException [(x, y)] => e2

Tail Recursion
-   Recursive call is at end of function
-   Not always possible

Functional Programming Concepts
-   Avoiding mutation of values
-   Using functions as values

First-class Functions
-   Can use them whenever we use values

Function Closures
-   Functions can use bindings from outside the function definition
    -   In scope where function is defined
-   Different from first-class functions

01/25/16

Datatype Bindings
-   Ex:
    datatype mytype = TwoInts of int * int
                    | Str of string
                    | foo
-   You can use the types defined with this method later on
-   Expression Trees
    -   Ex:
        datatype exp = Constant of int
                     | Negate of exp
                     | Add of exp * exp
                     | Multiply of exp * exp
-	Each-of pattern matching
	-	Pattern (x1, x2, ... , xn) matches tuple value (v1, v2, ... , vn)
	-	Pattern { f1 = x1, ... , fn = xn } matches record value { f1 = v1, ... , fn = vn}
-	Val-binding patterns
	-	val-binding can use a pattern
	-	Ex:
		fun sum_triple triple =
			let 
				val (x, y, z) = triple
			in
				x + y + z
			end
	-	Function-argument patterns
		-	Match against the argument in a pattern
		-	Ex:
			fun full_name {first=x, middle=y, last=z} =
				x ^ " " ^ y ^ " " ^ z
				
Generic Types
-	The 'a can stand for any type, but only one type
	-	Referred to type variable
	-	Ex:
		'a list
            
01/22/16

Boolean Operators
-   andalso, orelse, not

Comparisons
-   <, <=, >, >= can be used with two ints or two reals
-   <>, = can be used with two ints but NOT two reals
        
Immutability
-   No assignment statements
-   Don't have to worry about functions changing your data

Building Bigger Types
-   Type building blocks
    -   "Each of" - a t value contains values each of t1, t2, ... , tn
    -   "One of" - a t value contains values of one of t1, t2, ... , tn
    -   "Self reference" - a t value can refer to other t values
-   "Each of" types
    -   Records
        -   have named fields
        -   values: { f1 = v1, ... , fn = vn }
        -   types: { f1 : t1, ... , fn : tn }
        -   building: { f1 = e1, ... , fn = en }
        -   accessing: #fieldName recordName
        -   tuples are basically records of the form { 1 = v1, 2 = v2, ... , n = vn }

01/20/16

Let Expressions
-   Adds scope to bindings
-   Ex:
    fun foo(x : int) =
    let val y = if x > 0 then x + 3 else 2
    in
        2 * y + x
    end
-   Can also do functions
    -   Ex:
        let fun goo() =
            "goo"
            
Options
-   Let you return 'null' instead of an actual value
-   t option is a type for any type t
    -   Much like t list, but a different type (not a list)
-   Building
    -   NONE has typ 'a option
    -   SOME e has type t option if e has type t
-   Accessing
    -   isSome has type 'a option -> bool
    -   valOf has type 'a option -> 'a
        
01/15/16

Tuples
-   (e1, e2, ... en)
    -   Evaluates to (v1, v2, ... vn)
    -  #1, #2, ... #n accesses the corresponding element
        -   #loc tuple -> tuple[loc - 1]
-   Most basic: pairs (2-tuples)
-   Can be any collection of types (not all items must be the same type)
-   Ex:
    fun swap (pr : int*bool) = 
        (#2 pr, #1 pr)
-   Nesting
    -   (e1, (e2, e3)) is valid
    
Lists
-   Empty list: []
-   All values must be the same data type
-   Appending
    -   Let e1 evaluate to v0
        Let e2 evaluate to [v1, v2, ... , vn]
        Then e1::e2 evaluate to [v0, v1, v2, ... , vn]
    -   For e1::e2 to work, e1 must be of type 't' and e2 must be of type 't list'
-   Null: 'null e' evaluates to 'true' iff e evaluates to []

01/13/16

Addition
-	e1 + e2 where e1, e2 are expressions
-	if e1, e2 have type int, e1 + e2 have type int

Conditionals
-	if ... then ... else
-	Ex:
	if
		x > 3
	then
		5
	else
		x + 4

Function Bindings
-   fun x0 (x1 : t1, ... , xn : tn) = e
-   A function is a value.
-   New kind of type: (t1 * ... * tn) -> t
    -   Result type on right
    -   x0 gets this type 
    
Function Calls
-   e0 (e1, ... , en)
    -   Parentheses optional if only one argument
-   Type checking
    -   if e0 has some type (t1 * ... * tn) -> t
        and e1 has type t1
        and en has type tn
        then e0 (e1, ... , en) has type t
    